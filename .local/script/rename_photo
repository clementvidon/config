#!/bin/bash

# @author       clemedon (ClÃ©ment Vidon)
# @brief        Rename pictures based on their creation date, file size, and a user-defined prefix
# @usage        ./rename_pictures.sh /path/to/directory "MY_PREFIX" [ "filetype" ]
#
# Also generates a hidden undo script in the target directory.
#
# Depends on: exiftool

# Check for the presence of exiftool
if ! command -v exiftool &> /dev/null; then
    echo "exiftool is required but not installed. Please install it and try again."
    exit 1
fi

# Detect the operating system and set the appropriate stat command
if [[ "$(uname)" == "Darwin" ]]; then
    STAT_CMD="stat -f%z"
elif [[ "$(uname)" == "Linux" ]]; then
    STAT_CMD="stat -c%s"
else
    echo "Unsupported operating system."
    exit 1
fi

# Check if the target directory and prefix are provided
if [ -z "$1" ] || [ -z "$2" ]; then
    echo "Usage: $0 /path/to/directory PREFIX"
    exit 1
fi

# Assign the target directory and prefix
target_dir="$1"
prefix="$2"
filetype="${3:-}"
supported_ext="JPG|JPEG|PNG"
if [ -n "$filetype" ]; then
    supported_ext="${supported_ext}|${filetype^^}"  # Convert to uppercase
fi

# Create the undo script in the target directory
undo_script="$target_dir/.undo_$(date +"%y%m%d_%H%M%S").sh"
echo "#!/bin/bash" > "$undo_script"
chmod +x "$undo_script"

# Regex pattern for date validation (YYMMDDHHMMSS)
date_pattern="^[0-9]{12}$"
filename_pattern="^${prefix}[0-9]{2}_[0-9]{4}_[0-9]{6}_[0-9]{8}\.[A-Z0-9]{3,4}$"

# Count the total number of files that do not match the renamed pattern and are not hidden
total_files=$(find "$target_dir" -type f ! -name ".*" | wc -l)
processed=0
success=0
failures=0

# Iterate over files in the target directory
# Load all filenames into an array that do not match the renamed pattern and exclude hidden files
file_list=($(find "$target_dir" -type f ! -name ".*" ))

print_failure() {
    echo -e "\033[31m$1\033[0m"
}

# Iterate over the array of filenames
for f in "${file_list[@]}"; do
    ((processed++))
    basename_f=$(basename "$f")

    # Check if it's a non-empty file
    if [ ! -f "$f" ]; then
        ((failures++))
        print_failure "$processed/$total_files failure: '$basename_f' is not a regular file"
        continue
    elif [ ! -s "$f" ]; then
        ((failures++))
        print_failure "$processed/$total_files failure: '$basename_f' is an empty file"
        continue
    fi

    # Check the file extension (only process common image files)
    ext="${f##*.}"
    ext="${ext^^}"
    if [[ ! "$ext" =~ ^(${supported_ext})$ ]]; then
        ((failures++))
        print_failure "$processed/$total_files failure: '$basename_f' has an unsupported file extension"
        continue
    fi

    # Attempt to get the creation date from multiple EXIF tags
    date_tags=("DateTimeOriginal" "CreateDate" "MediaCreateDate" "FileCreateDate" "ModifyDate")
    exif_date=""
    for tag in "${date_tags[@]}"; do
        exif_date=$(exiftool -m -s3 -$tag -d "%y%m%d%H%M%S" "$f")
        if [[ "$exif_date" =~ $date_pattern ]]; then
            break
        fi
    done

    # If no valid date was found, count as a failure
    if [ -z "$exif_date" ]; then
        ((failures++))
        print_failure "$processed/$total_files failure: could not extract date (no EXIF data) for '$basename_f'"
        continue
    fi

    # Split the date and get the file size
    year="${exif_date:0:2}"
    month="${exif_date:2:2}"
    day="${exif_date:4:2}"
    time="${exif_date:6:6}"
    bytes=$(printf "%08d" "$($STAT_CMD "$f")")

    # Define the new filename
    newfile="$target_dir/${prefix}${year}_${month}${day}_${time}_${bytes}.${ext}"

    # Rename the file and log the undo command
    if mv -nv "$f" "$newfile" &>>/tmp/rename_images_mv_logs; then
        echo "$processed/$total_files success: renamed '$basename_f' -> '$newfile'"
        echo "mv -nv \"$newfile\" \"$f\"" >> "$undo_script"
        ((success++))
    else
        ((failures++))
        print_failure "$processed/$total_files failure: could not rename '$basename_f'"
    fi
done

# Final summary
echo "Renaming complete: $success successful, $failures failed."
