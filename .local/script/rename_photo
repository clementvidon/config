#!/bin/bash

# @author       clemedon (ClÃ©ment Vidon)
# @brief        Rename pictures based on their creation date, file size, and a user-defined prefix
# @usage        ./rename_pictures.sh /path/to/directory "MY_PREFIX"
#
# Also generates a hidden undo script in the target directory.
#
# Depends on: exiftool

# Check for the presence of exiftool
if ! command -v exiftool &> /dev/null; then
    echo "exiftool is required but not installed. Please install it and try again."
    exit 1
fi

# Detect the operating system and set the appropriate stat command
if [[ "$(uname)" == "Darwin" ]]; then
    STAT_CMD="stat -f%z"
    FILE_DATE_CMD="stat -f%B"
elif [[ "$(uname)" == "Linux" ]]; then
    STAT_CMD="stat -c%s"
    FILE_DATE_CMD="stat -c%W"
else
    echo "Unsupported operating system."
    exit 1
fi

# Check if the target directory is provided
if [ -z "$1" ]; then
    echo "You have to specify a target directory."
    exit 1
fi

# Check if the prefix is provided
if [ -z "$2" ]; then
    echo "You have to specify a prefix for all the filenames (e.g., GR3_CV or PHONE_CV)."
    exit 1
fi

# Assign the target directory and prefix
target_dir="$1"
prefix="$2"

# Create the undo script in the target directory
undo_script="$target_dir/.undo_$(date +"%y%m%d%H%M%S").sh"
echo "#!/bin/bash" > "$undo_script"
chmod +x "$undo_script"

# Regex pattern for date validation (YYMMDDHHMMSS)
date_pattern="^[0-9]{12}$"
# Regex pattern to match the desired file naming format
filename_pattern="^${prefix}[0-9]{2}_[0-9]{4}_[0-9]{6}_[0-9]{8}\.[A-Z0-9]{3,4}$"
         pattern="^${prefix}[0-9]{2}_[0-9]{4}_[0-9]{6}_[0-9]{8}\.[A-Z0-9]{3,4}$"

# Iterate over files in the target directory
for f in "$target_dir"/*; do
    # Check if it's a non-empty file
    if [ -f "$f" ] && [ -s "$f" ]; then
        basename_f=$(basename "$f")

        # Skip files that already match the pattern
        if [[ "$basename_f" =~ $filename_pattern ]]; then
            echo "Skipping already renamed file: $f"
            continue
        fi

        # Attempt to get the creation date from multiple EXIF tags
        date_tags=("DateTimeOriginal" "CreateDate" "MediaCreateDate" "FileCreateDate" "ModifyDate")
        exif_date=""

        # Iterate through each date tag and validate the extracted date
        for tag in "${date_tags[@]}"; do
            exif_date=$(exiftool -m -s3 -$tag -d "%y%m%d%H%M%S" "$f")

            # Check if the date is valid
            if [[ "$exif_date" =~ $date_pattern ]]; then
                echo "Valid date found using $tag: $exif_date"
                break
            else
                echo "Invalid or empty date using $tag, trying next..."
                exif_date=""
            fi
        done

        # If no valid date was found, skip the file
        if [ -z "$exif_date" ]; then
            echo "No valid date found for $f, skipping..."
            continue
        fi

        # Split the date into year, month, day, hour, minute, and second
        year="${exif_date:0:2}"
        month="${exif_date:2:2}"
        day="${exif_date:4:2}"
        time="${exif_date:6:6}"

        # Get the file size in bytes and pad to 8 digits
        bytes=$(printf "%08d" "$($STAT_CMD "$f")")

        # Convert the file extension to uppercase
        ext="${f##*.}"
        ext=$(echo "$ext" | tr '[:lower:]' '[:upper:]')

		# Define the new filename with the specified prefix
		newfile="$target_dir/${prefix}${year}_${month}${day}_${time}_${bytes}.${ext}"

        # Rename the file and log the undo command
        mv -vn "$f" "$newfile"
        echo "mv -v \"$newfile\" \"$f\"" >> "$undo_script"
    else
        echo "Skipping non-file or empty file: $f"
    fi
done
